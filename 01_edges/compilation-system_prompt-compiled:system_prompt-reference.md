---
type: edge/dependency
extends: edge
id: e:compilation:system_prompt-compiled:system_prompt-reference
name: Compilation - Compiled System Prompt derived from Reference
description: The compiled system_prompt document is generated from the reference document by expanding Obsidian embeds
source: v:system_prompt:claude-assistant-compiled
target: v:system_prompt:claude-assistant
source_type: vertex/system_prompt
target_type: vertex/system_prompt
orientation: directed
dependency_type: compilation
required: true
compilation_script: scripts/compile_document.py
deterministic: true
tags:
  - edge
  - dependency
  - compilation
version: 1.0.0
created: 2025-12-28T00:30:00Z
modified: 2025-12-28T00:30:00Z
---

# Compilation - Compiled System Prompt derived from Reference

This edge tracks that the compiled system_prompt document is generated from the reference document by deterministically expanding Obsidian embeds using a compilation script.

## Dependency Relationship

**Dependent:** [system_prompt-claude-assistant-compiled](../00_vertices/system_prompt-claude-assistant-compiled.md) - Standalone, deployable system prompt
**Dependency:** [system_prompt-claude-assistant](../00_vertices/system_prompt-claude-assistant.md) - Reference document with embeds
**Relationship:** compiled document is derived from reference (compilation)

**Usage:** The reference document uses Obsidian embed syntax (`![[filename]]`) to include component documents (persona, purpose, protocol). The compiled document is generated by expanding these embeds inline, creating a standalone markdown file suitable for deployment or assurance verification.

**Assurance Note:** This compilation edge is separate from both:
- Component dependencies (reference → persona/purpose/protocol via dependency edges)
- Assurance relationships (compiled document verified against spec:system_prompt)

The compiled document is what gets assured, not the reference document.

## Dependency Usage

**Compilation Process:**
- Input: Reference document (`system_prompt-claude-assistant.md`) with embeds
- Process: Run `scripts/compile_document.py` to expand all `![[...]]` embeds
- Output: Compiled document (`system_prompt-claude-assistant-compiled.md`) with inline content
- Deterministic: Same reference always produces same compiled output

**Script:** `scripts/compile_document.py`

**Command:**
```bash
python scripts/compile_document.py \
    00_vertices/system_prompt-claude-assistant.md \
    00_vertices/system_prompt-claude-assistant-compiled.md
```

**Required:** Yes - the compiled document MUST be regenerated whenever:
- The reference document changes
- Any component document (persona, purpose, protocol) changes
- The compilation script is updated

**Cardinality:** One compiled document per reference document (1:1)

## Compositional Justification

**Why Compilation:** The PPP framework uses Obsidian embeds for maintainability and single source of truth, but assurance verification requires standalone documents. Compilation provides:
- **Authoring efficiency:** Reference doc uses embeds, readable in Obsidian
- **Deployment readiness:** Compiled doc is standalone, no external dependencies
- **Assurance target:** Compiled doc is what gets verified against spec:system_prompt
- **Deterministic rebuild:** Compilation is reproducible, compiled doc is a cache

**Not Source Control:** The compiled document is a generated artifact (cache), not a source document. The reference document and components are the canonical sources.

**Not Assurance:** This edge doesn't prove quality. The compiled document must still be verified (structural) and validated (quality) independently.

## Cache Semantics

The compiled document is a **cache** with these properties:
- **Derived:** Generated from source (reference + components)
- **Regeneratable:** Can be rebuilt deterministically at any time
- **Stale detection:** If reference or components change, compiled doc should be rebuilt
- **Version tracked:** Git tracks compiled doc for convenience, but it can always be regenerated

**Rebuild Strategy:**
- Manual: Run compilation script when needed
- Automated: Could use git hooks or CI to auto-rebuild on changes
- Verification: Compare timestamps or content hashes to detect staleness

## Relationship to Component Dependencies

**Transitive Dependencies:**
The compiled document transitively depends on:
1. Reference document (direct via this edge)
2. Persona component (indirect via reference → persona dependency)
3. Purpose component (indirect via reference → purpose dependency)
4. Protocol component (indirect via reference → protocol dependency)

**Dependency Graph:**
```
compiled --compilation--> reference --dependency--> persona
                                   --dependency--> purpose
                                   --dependency--> protocol
```

Changes to ANY component require recompiling.

## Verification Target

**Critical:** The COMPILED document is the verification target for system_prompt assurance, not the reference document.

**Why:** The spec for system_prompt expects inline content in the Persona, Purpose, and Protocol sections. The reference document has embeds (not inline content), so it satisfies the compositional pattern but not the deployment spec. The compiled document satisfies the deployment spec.

**Assurance Flow:**
1. Components verified individually (persona → spec:persona, etc.)
2. Reference doc shows compositional structure (dependency edges)
3. Compiled doc generated from reference
4. **Compiled doc verified against spec:system_prompt** ✓
5. **Compiled doc validated against guidance:system_prompt** ✓
6. Assurance face for compiled doc

---

**Note:** This is a compilation dependency (generated → source), modeling "derived-from" relationships. The compiled document is a cache that must be regenerated when dependencies change. Protocol is designed LAST in PPP to integrate persona and purpose.
